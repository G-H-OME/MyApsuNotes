# 算法题目

## 矩阵中的路径

```typescript
function exist(board: string[][], word: string): boolean {
    const wordArr = word.split("")
    const lineNum = board.length - 1
    const colNum = board[0].length - 1
    let i = 0
    let j = 0
    const z = [board[0][0]] //z=['A']
    board[0][0] = ""
    let result = null
    const dfs = (i: number, j: number, z: string[], board: string[][]) => {
      const Arr = [
        { item: board[i + 1 > lineNum ? i : i + 1][j], index: [i + 1, j] },
        { item: board[i][j + 1 > colNum ? j : j + 1], index: [i, j + 1] },
        { item: board[i - 1 < 0 ? i : i - 1][j], index: [i - 1, j] },
        { item: board[i][j - 1 < 0 ? j : j - 1], index: [i, j - 1] },
      ]
      const filterArr = Arr.filter((item) => item.item === wordArr[z.length])
      if (filterArr.length > 0) {
        filterArr.forEach((item) => {
          z.push(item.item)
          board[item.index[0]][item.index[1]] = ""
          i = item.index[0]
          j = item.index[1]
          dfs(i, j, z, board)
        })
      } else {
        if (JSON.stringify(z) === JSON.stringify(wordArr)) {
          console.log({
            wordArr: JSON.stringify(wordArr),
            z: JSON.stringify(z),
          })
          return (result = true)
        }
        return (result = false)
      }
    }
    dfs(i, j, z, board)
    return result
};
```

错误：题目中没有说一定从（0，0）开始。得考虑从别的点进入的可能性。

```typescript
function exist(board: string[][], word: string): boolean {
    const newBoard = board
    const wordArr = word.split("")
    const lineNum = board.length - 1
    const colNum = board[0].length - 1
    let i = 0
    let j = 0
    let z = []
    let result = null
    const firstLocation: [number, number][] = []
    board.forEach((one, index) => {
      one.forEach((two, index2) => {
        if (two === wordArr[0]) {
          firstLocation.push([index, index2])
        }
      })
    })

    const dfs = (i: number, j: number, z: string[], board: string[][]) => {
      const Arr = [
        { item: board[i + 1 > lineNum ? i : i + 1][j], index: [i + 1, j] },
        { item: board[i][j + 1 > colNum ? j : j + 1], index: [i, j + 1] },
        { item: board[i - 1 < 0 ? i : i - 1][j], index: [i - 1, j] },
        { item: board[i][j - 1 < 0 ? j : j - 1], index: [i, j - 1] },
      ]
      const filterArr = Arr.filter((item) => item.item === wordArr[z.length])
      if (filterArr.length > 0) {
        filterArr.forEach((item) => {
          z.push(item.item)
          board[item.index[0]][item.index[1]] = ""
          i = item.index[0]
          j = item.index[1]
          dfs(i, j, z, board)
        })
      } else {
        if (JSON.stringify(z) === JSON.stringify(wordArr)) {
          return (result = true)
        }
        return (result = false)
      }
    }

    const back: boolean[] = firstLocation.map((item) => {
      i = 0
      j = 0
      z = []
      result = null
      const boards = newBoard
      z.push(boards[item[0]][item[1]])
      board[item[0]][item[1]] = ""
      i = item[0]
      j = item[1]
      dfs(i, j, z, boards)
      return result
    })

    return back.includes(true)
};
```

增加了从任意一个满足的点进入的可能，但是报了很怪的错，我tm。居然显示刚传进来的board里的A全部没了。



## 机器人的运动范围

```typescript
function movingCount(m: number, n: number, k: number): number {
    let canGoNum = 0

    function addNum(num:number):number{
    if (num === 100) return 1
    return (num % 10) + (num - (num % 10)) / 10
}

    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        if (addNum(i) + addNum(j) <= k) {
          canGoNum++
        }
      }
    }
    return canGoNum
};
```

错了，估计是跳格子了。还是得广度遍历。

```typescript
const movingCount = (m: number, n: number, k: number) => {
    if (k === 0) return 1
    const columnArr: number[] = new Array(n).fill(0)
    const mapArr: number[] = new Array(m).fill(columnArr)
    let sum = 1
    mapArr[0][0] = 1
    console.log({ mapArr })

    const dfs = (line: number, column: number) => {
      const Arr = [
        {
          num: line + 1 > m ? 1 : mapArr[line + 1][column],
          index: [line + 1, column],
        },
        {
          num: column + 1 > n ? 1 : mapArr[line][column + 1],
          index: [line, column + 1],
        },
        {
          num: line - 1 < 0 ? 1 : mapArr[line - 1][column],
          index: [line - 1, column],
        },
        {
          num: column - 1 < 0 ? 1 : mapArr[line][column - 1],
          index: [line, column - 1],
        },
      ]

      const filterArr = Arr.filter((item) => {
        return (
          item.num === 0 && addNum(item.index[0]) + addNum(item.index[1]) <= k
        )
      })

      if (filterArr.length > 0) {
        console.log({ filterArr })

        filterArr.forEach((item) => {
          sum++
          mapArr[item.index[0]][item.index[1]] = 1
          console.log({ line: item.index[0], column: item.index[1] })

          dfs(item.index[0], item.index[1])
        })
      }
    }
    dfs(0, 0)

    return sum
  }
```

真是不知道为啥会酱紫
