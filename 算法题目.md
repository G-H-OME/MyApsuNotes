# 算法题目

## 矩阵中的路径

```typescript
function exist(board: string[][], word: string): boolean {
    const wordArr = word.split("")
    const lineNum = board.length - 1
    const colNum = board[0].length - 1
    let i = 0
    let j = 0
    const z = [board[0][0]] //z=['A']
    board[0][0] = ""
    let result = null
    const dfs = (i: number, j: number, z: string[], board: string[][]) => {
      const Arr = [
        { item: board[i + 1 > lineNum ? i : i + 1][j], index: [i + 1, j] },
        { item: board[i][j + 1 > colNum ? j : j + 1], index: [i, j + 1] },
        { item: board[i - 1 < 0 ? i : i - 1][j], index: [i - 1, j] },
        { item: board[i][j - 1 < 0 ? j : j - 1], index: [i, j - 1] },
      ]
      const filterArr = Arr.filter((item) => item.item === wordArr[z.length])
      if (filterArr.length > 0) {
        filterArr.forEach((item) => {
          z.push(item.item)
          board[item.index[0]][item.index[1]] = ""
          i = item.index[0]
          j = item.index[1]
          dfs(i, j, z, board)
        })
      } else {
        if (JSON.stringify(z) === JSON.stringify(wordArr)) {
          console.log({
            wordArr: JSON.stringify(wordArr),
            z: JSON.stringify(z),
          })
          return (result = true)
        }
        return (result = false)
      }
    }
    dfs(i, j, z, board)
    return result
};
```

错误：题目中没有说一定从（0，0）开始。得考虑从别的点进入的可能性。

```typescript
function exist(board: string[][], word: string): boolean {
    const newBoard = board
    const wordArr = word.split("")
    const lineNum = board.length - 1
    const colNum = board[0].length - 1
    let i = 0
    let j = 0
    let z = []
    let result = null
    const firstLocation: [number, number][] = []
    board.forEach((one, index) => {
      one.forEach((two, index2) => {
        if (two === wordArr[0]) {
          firstLocation.push([index, index2])
        }
      })
    })

    const dfs = (i: number, j: number, z: string[], board: string[][]) => {
      const Arr = [
        { item: board[i + 1 > lineNum ? i : i + 1][j], index: [i + 1, j] },
        { item: board[i][j + 1 > colNum ? j : j + 1], index: [i, j + 1] },
        { item: board[i - 1 < 0 ? i : i - 1][j], index: [i - 1, j] },
        { item: board[i][j - 1 < 0 ? j : j - 1], index: [i, j - 1] },
      ]
      const filterArr = Arr.filter((item) => item.item === wordArr[z.length])
      if (filterArr.length > 0) {
        filterArr.forEach((item) => {
          z.push(item.item)
          board[item.index[0]][item.index[1]] = ""
          i = item.index[0]
          j = item.index[1]
          dfs(i, j, z, board)
        })
      } else {
        if (JSON.stringify(z) === JSON.stringify(wordArr)) {
          return (result = true)
        }
        return (result = false)
      }
    }

    const back: boolean[] = firstLocation.map((item) => {
      i = 0
      j = 0
      z = []
      result = null
      const boards = newBoard
      z.push(boards[item[0]][item[1]])
      board[item[0]][item[1]] = ""
      i = item[0]
      j = item[1]
      dfs(i, j, z, boards)
      return result
    })

    return back.includes(true)
};
```

增加了从任意一个满足的点进入的可能，但是报了很怪的错，我tm。居然显示刚传进来的board里的A全部没了。



## 机器人的运动范围

```typescript
function movingCount(m: number, n: number, k: number): number {
    let canGoNum = 0

    function addNum(num:number):number{
    if (num === 100) return 1
    return (num % 10) + (num - (num % 10)) / 10
}

    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        if (addNum(i) + addNum(j) <= k) {
          canGoNum++
        }
      }
    }
    return canGoNum
};
```

错了，估计是跳格子了。还是得广度遍历。

```typescript
const movingCount = (m: number, n: number, k: number) => {
    if (k === 0) return 1
    const columnArr: number[] = new Array(n).fill(0)
    const mapArr: number[] = new Array(m).fill(columnArr)
    let sum = 1
    mapArr[0][0] = 1
    console.log({ mapArr })

    const dfs = (line: number, column: number) => {
      const Arr = [
        {
          num: line + 1 > m ? 1 : mapArr[line + 1][column],
          index: [line + 1, column],
        },
        {
          num: column + 1 > n ? 1 : mapArr[line][column + 1],
          index: [line, column + 1],
        },
        {
          num: line - 1 < 0 ? 1 : mapArr[line - 1][column],
          index: [line - 1, column],
        },
        {
          num: column - 1 < 0 ? 1 : mapArr[line][column - 1],
          index: [line, column - 1],
        },
      ]

      const filterArr = Arr.filter((item) => {
        return (
          item.num === 0 && addNum(item.index[0]) + addNum(item.index[1]) <= k
        )
      })

      if (filterArr.length > 0) {
        console.log({ filterArr })

        filterArr.forEach((item) => {
          sum++
          mapArr[item.index[0]][item.index[1]] = 1
          console.log({ line: item.index[0], column: item.index[1] })

          dfs(item.index[0], item.index[1])
        })
      }
    }
    dfs(0, 0)

    return sum
  }
```

真是不知道为啥会酱紫

## 力扣77题：

```typescript
function combine(n: number, k: number): number[][] {
    const path:number[] = []
    const result:number[][] = []
    const backtracking = (n: number,k: number,startIndex: number)=>{
        if(path.length===k){
            return result.push(path.map((i) => i))
        }
        for(let i = startIndex;i<=n;i++){
            path.push(i)
            backtracking(n,k,i+1)
            path.pop()
        }
    }
    backtracking(n,k,1)

    return result
};
```

我害怕每次在终止条件里都有一个map会消耗时间，所以想用map

```typescript
function combine(n: number, k: number): number[][] {
    const path:number[] = []
    const result:number[][] = []
    const map:Map<number,number> = new Map()
    const backtracking = (n: number,k: number,startIndex: number)=>{
        if(path.length===k){
            return result.push(Array.from(map.values()))
        }
        for(let i = startIndex;i<=n;i++){
            path.push(i)
            map.set(path.length,i)
            backtracking(n,k,i+1)
            path.pop()
        }
    }
    backtracking(n,k,1)

    return result
};
```

实际上用起来没差多少。。。

```typescript
function combine(n: number, k: number): number[][] {
    const result:number[][] = []
    const map:Map<number,number> = new Map()
    const backtracking = (n: number,k: number,startIndex: number)=>{
        if(map.size===k){
            return result.push(Array.from(map.values()))
        }
        for(let i = startIndex;i<=n;i++){
            map.set(path.length,i)
            backtracking(n,k,i+1)
            map.delete(map.size)
        }
    }
    backtracking(n,k,1)

    return result
};
```

不死心想写个更快的。。。结果 更慢了这个。空间占用也更多 pass。

### 剪枝操作

由于k的限制，如果从某个startIndex起到n的个数达不到k的话，那它后面的节点肯定都达不到条件，因此可以将他们剪枝。而剪枝操作优化的部分是for循环中的逻辑。因此这样修改：例如上题中：

```typescript
for(let i = startIndex;i<=n;i++){
            map.set(path.length,i)
            backtracking(n,k,i+1)
            map.delete(map.size)
        }
//将里面的 i<=n 条件限制修改。实际上限制的是startIndex。而他们的关系是，拿个n=4，k=3举例：
//只有startIndex<=2满足条件
//n=4 k=3 startIndex<=2 ，n-startIndex+1为for循环的次数（+1是因为要加上startIndex自己）。循环的次数应该>=k,而startIndex每+1，path里都会多一个元素，因此他们其实是互相关联的，因为每个递归中的startIndex都不同，所以需要path去帮助管理，因为在for循环中 i = startIndex，所以关系就变成
//n-i+path.length+1>=k  =>  i<=n-k+path.length+1

for(let i = startIndex;i<=n-k+path.length+1;i++){
            map.set(path.length,i)
            backtracking(n,k,i+1)
            map.delete(map.size)
        }
//也可以换一种方式理解，k-path.length等于还差几位，n-i+1表示剩余可放入的数量。剩余可放入的数量应该>=还差几位  得到：n-i+1>=k-path.length => i<=n-(k-path.length)+1
```



## 力扣78题：

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

有了这个示例好理解一些。类似于第77题，需要做一些变化，但是不多。其实更加简单了因为不需要用k来

```typescript
function subsets(nums: number[]): number[][] {
    const path:number[] = []
    const result:number[][] = []
    const backtracking = (startIndex:number)=>{
        result.push(path.map(i=>i))
        if (path[path.length - 1] === nums[nums.length - 1]) return
        for (let i = startIndex; i < nums.length; i++) {
            path.push(nums[i])
            backtracking(i + 1)
            path.pop()
        }
    }
    backtracking(0)
    return result
};
```

