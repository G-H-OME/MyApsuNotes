# 算法题目

## 矩阵中的路径

```typescript
function exist(board: string[][], word: string): boolean {
    const wordArr = word.split("")
    const lineNum = board.length - 1
    const colNum = board[0].length - 1
    let i = 0
    let j = 0
    const z = [board[0][0]] //z=['A']
    board[0][0] = ""
    let result = null
    const dfs = (i: number, j: number, z: string[], board: string[][]) => {
      const Arr = [
        { item: board[i + 1 > lineNum ? i : i + 1][j], index: [i + 1, j] },
        { item: board[i][j + 1 > colNum ? j : j + 1], index: [i, j + 1] },
        { item: board[i - 1 < 0 ? i : i - 1][j], index: [i - 1, j] },
        { item: board[i][j - 1 < 0 ? j : j - 1], index: [i, j - 1] },
      ]
      const filterArr = Arr.filter((item) => item.item === wordArr[z.length])
      if (filterArr.length > 0) {
        filterArr.forEach((item) => {
          z.push(item.item)
          board[item.index[0]][item.index[1]] = ""
          i = item.index[0]
          j = item.index[1]
          dfs(i, j, z, board)
        })
      } else {
        if (JSON.stringify(z) === JSON.stringify(wordArr)) {
          console.log({
            wordArr: JSON.stringify(wordArr),
            z: JSON.stringify(z),
          })
          return (result = true)
        }
        return (result = false)
      }
    }
    dfs(i, j, z, board)
    return result
};
```

错误：题目中没有说一定从（0，0）开始。得考虑从别的点进入的可能性。

```typescript
function exist(board: string[][], word: string): boolean {
    const newBoard = board
    const wordArr = word.split("")
    const lineNum = board.length - 1
    const colNum = board[0].length - 1
    let i = 0
    let j = 0
    let z = []
    let result = null
    const firstLocation: [number, number][] = []
    board.forEach((one, index) => {
      one.forEach((two, index2) => {
        if (two === wordArr[0]) {
          firstLocation.push([index, index2])
        }
      })
    })

    const dfs = (i: number, j: number, z: string[], board: string[][]) => {
      const Arr = [
        { item: board[i + 1 > lineNum ? i : i + 1][j], index: [i + 1, j] },
        { item: board[i][j + 1 > colNum ? j : j + 1], index: [i, j + 1] },
        { item: board[i - 1 < 0 ? i : i - 1][j], index: [i - 1, j] },
        { item: board[i][j - 1 < 0 ? j : j - 1], index: [i, j - 1] },
      ]
      const filterArr = Arr.filter((item) => item.item === wordArr[z.length])
      if (filterArr.length > 0) {
        filterArr.forEach((item) => {
          z.push(item.item)
          board[item.index[0]][item.index[1]] = ""
          i = item.index[0]
          j = item.index[1]
          dfs(i, j, z, board)
        })
      } else {
        if (JSON.stringify(z) === JSON.stringify(wordArr)) {
          return (result = true)
        }
        return (result = false)
      }
    }

    const back: boolean[] = firstLocation.map((item) => {
      i = 0
      j = 0
      z = []
      result = null
      const boards = newBoard
      z.push(boards[item[0]][item[1]])
      board[item[0]][item[1]] = ""
      i = item[0]
      j = item[1]
      dfs(i, j, z, boards)
      return result
    })

    return back.includes(true)
};
```

增加了从任意一个满足的点进入的可能，但是报了很怪的错，我tm。居然显示刚传进来的board里的A全部没了。